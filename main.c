#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <gmp.h>
#define ui_int unsigned long int
#define SIZE 100000
#define TRIAL_PRIMES 9592

/**
 * readLine - ...
 * @file: the file to read from
 *
 * Return: pointer to the command
 */
char *readLine(FILE * file)
{
	char *line = NULL;
	size_t n = 0;
	int r_line;

	r_line = getline(&line, &n, file);
	if (r_line == -1)
	{
		free(line);
		return (NULL);
	}
	return (line);
}

/**
 * sieve - ...
 * @primes: ...
 * @is_prime: ...
 */
void sieve(int primes[], int is_prime[])
{
	int i, j, k = 2, cnt = 0;

	for (i = 5; i * i <= SIZE; i += k)
	{
		cnt++;
		if (cnt & 1)
			k = 2;
		else
			k = 4;
		if (is_prime[i] == 0)
		{
			for (j = i * i; j <= SIZE; j += i)
				is_prime[j] = 1;
		}
	}

	j = 2, k = 2, cnt = 0;

	for (i = 5; i < SIZE; i += k)
	{
		cnt++;
		if (cnt & 1)
			k = 2;
		else
			k = 4;
		if (is_prime[i] == 0)
		{
			primes[j] = i;
			j++;
		}
	}
}

/**
 * trialdiv - try primes generated by sieve
 * @buffer: ...
 * @primes: ...
 *
 * Return: 1 on success, 0 otherwise
 */
int trialdiv(char *buffer, int primes[])
{
	int i;
	mpz_t n, div;

	mpz_init(n);
	mpz_init(div);

	mpz_set_str(n, buffer, 10);
	for (i = 0; i < TRIAL_PRIMES; i++)
	{
		mpz_mod_ui(div, n, primes[i]);

		if (mpz_cmp_ui(div, 0) == 0)
		{
			mpz_out_str(stdout, 10, n), printf("=%i*", primes[i]);
			mpz_divexact_ui(n, n, primes[i]);
			mpz_out_str(stdout, 10, n), printf("\n");
			mpz_clear(n);
			mpz_clear(div);
			return (1);
		}
	}
	mpz_clear(n), mpz_clear(div);
	return (0);
}

/**
 * pollard - Pollard's Rho method
 * @buffer: the composite n
 */
void pollard(char *buffer)
{
	mpz_t n, x, y, _gcd, abs;
	ui_int i = 2;

	mpz_init(n), mpz_init(x), mpz_init(_gcd), mpz_init(y);
	mpz_init(abs);

	mpz_set_str(n, buffer, 10), mpz_set_ui(x, i);
	mpz_set(y, x), mpz_set_ui(_gcd, 1);

	while (mpz_cmp_ui(_gcd, 1) == 0)
	{
		mpz_pow_ui(x, x, 2), mpz_add_ui(x, x, 1);
		mpz_mod(x, x, n);

		mpz_pow_ui(y, y, 2), mpz_add_ui(y, y, 1);
		mpz_mod(y, y, n);

		mpz_pow_ui(y, y, 2), mpz_add_ui(y, y, 1);
		mpz_mod(y, y, n);

		mpz_sub(abs, x, y);
		mpz_abs(abs, abs);
		mpz_gcd(_gcd, abs, n);
		if (mpz_cmp(_gcd,  n) == 0)
		{
			mpz_add_ui(x, x, 1), mpz_set(y, x), mpz_set_ui(_gcd, 1);
		}
	}
	mpz_out_str(stdout, 10, n), printf("=");
	mpz_out_str(stdout, 10, _gcd), printf("*");
	mpz_divexact(n, n, _gcd);
	mpz_out_str(stdout, 10, n), printf("\n");
	mpz_clear(n), mpz_clear(_gcd), mpz_clear(abs), mpz_clear(x), mpz_clear(y);
}

/**
 * main - main function
 * @argc: number of arguments
 * @argv: arguments vector
 *
 * Return: ...
 */
int main(int argc, char *argv[])
{
	char *buffer = NULL;
	int primes[TRIAL_PRIMES] = {0}, is_prime[SIZE] = {0};
	FILE *file;

	if (argc != 2)
		fprintf(stderr, "USAGE: factors file\n"), exit(EXIT_FAILURE);

	primes[0] = 2, primes[1] = 3;
	sieve(primes, is_prime);

	file = fopen(argv[1], "r");
	if (!file)
	{
		fprintf(stderr, "Error: Can't open file %s\n", argv[1]);
		exit(EXIT_FAILURE);
	}

	while (1)
	{
		buffer = readLine(file);

		if (buffer == NULL) /* EOF */
		{
			free(buffer);
			break;
		}
		if (trialdiv(buffer, primes) == 1)
		{
			free(buffer);
			continue;
		}
		pollard(buffer);
		free(buffer);
	}
	fclose(file);
	return (0);
}
